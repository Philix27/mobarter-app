// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: advert.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const advert_Create = `-- name: Advert_Create :one

INSERT INTO adverts (
  rate,  
  limit_lower, 
  limit_upper,
  currency_pair,
  instructions 
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5
)
RETURNING id, agent_id, payment_method_id, ad_status, currency_pair, limit_upper, limit_lower, rate, instructions, created_at, updated_at
`

type Advert_CreateParams struct {
	Rate         pgtype.Numeric
	LimitLower   pgtype.Numeric
	LimitUpper   pgtype.Numeric
	CurrencyPair NullCurrencypair
	Instructions pgtype.Text
}

// ! #SECTION Ads
func (q *Queries) Advert_Create(ctx context.Context, arg Advert_CreateParams) (Advert, error) {
	row := q.db.QueryRow(ctx, advert_Create,
		arg.Rate,
		arg.LimitLower,
		arg.LimitUpper,
		arg.CurrencyPair,
		arg.Instructions,
	)
	var i Advert
	err := row.Scan(
		&i.ID,
		&i.AgentID,
		&i.PaymentMethodID,
		&i.AdStatus,
		&i.CurrencyPair,
		&i.LimitUpper,
		&i.LimitLower,
		&i.Rate,
		&i.Instructions,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const advert_Delete = `-- name: Advert_Delete :exec
DELETE FROM adverts
WHERE id = $1
`

func (q *Queries) Advert_Delete(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, advert_Delete, id)
	return err
}

const advert_List = `-- name: Advert_List :many
SELECT id, agent_id, payment_method_id, ad_status, currency_pair, limit_upper, limit_lower, rate, instructions, created_at, updated_at FROM adverts
WHERE ad_status = $1 LIMIT 20
`

func (q *Queries) Advert_List(ctx context.Context, adStatus NullAdsstatus) ([]Advert, error) {
	rows, err := q.db.Query(ctx, advert_List, adStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Advert
	for rows.Next() {
		var i Advert
		if err := rows.Scan(
			&i.ID,
			&i.AgentID,
			&i.PaymentMethodID,
			&i.AdStatus,
			&i.CurrencyPair,
			&i.LimitUpper,
			&i.LimitLower,
			&i.Rate,
			&i.Instructions,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const advert_Update = `-- name: Advert_Update :exec
UPDATE adverts
  SET currency_pair = $2,
  limit_upper = $3,
  limit_lower = $4,
  rate = $5,
  instructions = $6
WHERE id = $1
`

type Advert_UpdateParams struct {
	ID           int64
	CurrencyPair NullCurrencypair
	LimitUpper   pgtype.Numeric
	LimitLower   pgtype.Numeric
	Rate         pgtype.Numeric
	Instructions pgtype.Text
}

func (q *Queries) Advert_Update(ctx context.Context, arg Advert_UpdateParams) error {
	_, err := q.db.Exec(ctx, advert_Update,
		arg.ID,
		arg.CurrencyPair,
		arg.LimitUpper,
		arg.LimitLower,
		arg.Rate,
		arg.Instructions,
	)
	return err
}

const getAdvert = `-- name: GetAdvert :one
SELECT id, agent_id, payment_method_id, ad_status, currency_pair, limit_upper, limit_lower, rate, instructions, created_at, updated_at FROM adverts
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetAdvert(ctx context.Context, id int64) (Advert, error) {
	row := q.db.QueryRow(ctx, getAdvert, id)
	var i Advert
	err := row.Scan(
		&i.ID,
		&i.AgentID,
		&i.PaymentMethodID,
		&i.AdStatus,
		&i.CurrencyPair,
		&i.LimitUpper,
		&i.LimitLower,
		&i.Rate,
		&i.Instructions,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
